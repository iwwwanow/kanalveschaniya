---
- делай ревью по чату:
    - https://chat.deepseek.com/a/chat/s/ed710248-632c-4279-8583-d28d4bca166e
---

- [ ] FIX: bun db:migrate не работает. можно запускаться только из инфры и только через npm run ...

- [x] 1. Неправильная обработка ошибок - Use Case смешивает исключения и Result объекты. Либо обрабатывай ВСЕ ошибки через Result, либо ВСЕ через исключения
- [?] 2. Отсутствие валидации Command - Command принимает Value Objects, но нет проверки их валидности на уровне Application
  - value-objects валидируется в конструкторе. следовательно они должны быть валидными и при создании
- [?] 3. Проблема race condition - между проверкой "не в очереди" и добавлением в очередь может вклиниться другой процесс
  - на уровне доменной логики можно ли както дописать то, что resourceUrl должен быть униальным?
  - если в очереди должно быть несколько объектов с одинаковым resourceUrl, для того, чтобы оповестить отправителя - как сделать? или создать дополнительную очередь для оповещения?
- [x] 4. Нарушение CQRS - Use Case возвращает Entity объекты (QueueTask, Resource), что раскрывает внутреннюю структуру
  - вообще не понимаю этого ограничения. много неудобств накладывает. например из application, при найденном ресурсе я бы просто его возаращал. а так мне нужно извлекать из resourceId
  - могу ли я использовать value-objects из entity в applicatoin/dto?
- [?] 5. Отсутствие фабрики для QueueTask - используется статический метод create, но нет обработки возможных ошибок создания
  - в комманд попадают уже value-objects. насколько понимаю, валидация в конструкторе, следовательно они все гарантированно валидные.
  - также, насколько понимаю, value-objects не должны попадать в инфрку. инфра передает в эппликейшн только строки. далее мы из них собираем value-objects и на месте валидируем. веро?
- [x] 6. Избыточный базовый Command класс - не несет полезной нагрузки, можно удалить
- [ ] 7. Проблема с оповещениями - архитектурно не решено, как оповещать пользователя в случае AlreadyQueued
  - мы возаращаем в инфру chatId, messageId, затем инфра оповещает
- [?] 8. Некорректные импорты типов - используются type imports там где нужны реальные классы
  - не понимаю где
- [x] 9. Отсутствие композиции Use Cases - весь сценарий в одном методе, сложно тестировать и расширять
- [x] 10. Неиспользуемые ошибки в Result - объявлены ValidationError и SystemError, но не используются
  - убрал
- [x] 11. Смешение уровней абстракции - Use Case знает о конкретных ошибках БД и файловой системы
  - убрал
- [-] 12. Отсутствие транзакционности - несколько операций с репозиториями не объединены в транзакцию
  - пока оставим
- [?] 13. Проблема с возвращаемыми данными - AlreadyQueued возвращает задачу, но нет информации о позиции в очереди
  - позиция в очереди будет считаться. нужно высчитывать количество задач сверху. они будут сортироваться по дате
- [?] 14. Жесткая зависимость от доменных Entity - Use Case напрямую возвращает доменные объекты
  - нужно добавлять в application-layer логику работы с оповещениями. както нужно прописать функции для отправки сообщений (или их интерфейсы)
  - далее через инфру прокидывать адаптер. логика будет вот тут
- [x] 15. Отсутствие мониторинга - нет логирования операций для отладки

---

- [ ] гоняй теперь ревью.
  - 2-3 ревью должно быть достаточно

---

### [ ] Почини критические ошибки (2-4 часа)

[x] Создать ScheduleDownloadCommand класс в application/dtos/
[x] Перенести resourceUrl, chatId, messageId в Command

- в целом, детализация комманды. что нужно для выполнения?
- обрати внимание, что ты будешь записывать в БД с айди чата и айди пользователя. также нужен УРЛ. думаю, имеет смысл сохранять еще и messageId, чтобы генерить ответ на сообщение
  [x] Изменить execute на async execute(command: ScheduleDownloadCommand)
  [x] Убрать any из возвращаемого типа

[x] Создать ScheduleDownloadResult тип с вариантами: - Success (task: QueueTask) - AlreadyDownloaded (resource: Resource) - AlreadyInQueue (task: QueueTask) - ValidationError (message: string)
[x] Определить какие ошибки доменные (AlreadyExists), какие системные (DatabaseError)
[x] Решить: доменные ошибки - часть Result, системные - исключения

[x] Сделать queueRepository и resourceRepository приватными
[x] Добавить async ко всем методам в Use Case
[x] Обновить интерфейсы репозиториев на Promise

[x] Реализовать проверку в ResourceRepository (скачан ли ранее)
[x] Реализовать проверку в QueueRepository (есть ли в очереди)
[x] Реализовать создание QueueTask и добавление в очередь
[x] Возвращать соответствующий Result вариант

### [ ] Проектирование архитектуры (1-2 часа)

### [ ] Реализация базового сценария (3-4 часа)

### [ ] Добавление обработки edge cases (2-3 часа)

# Последовательность рефакторинга Application Layer:

- [x] 1. Исправить сигнатуру execute - убрать any, определить Command объект
- [x] 2. Сделать зависимости приватными - убрать public readonly
- [x] 3. Добавить асинхронность - все методы async
- [x] 4. Определить типизированный Result - вместо any
- [x] 5. Выбрать стратегию Use Case - один большой или разделенные
- [x] 6. Определить границы транзакций - что атомарно, что нет
- [x] 7. Спроектировать обработку ошибок - доменные vs системные
- [x] 8. Определить входные DTO - Command vs Query объекты
- [-] 9. Реализовать проверку состояния - race condition protection
- [-] 10. Добавить доменные события - уведомления о изменениях
- [x] 11. Проектировать композицию Use Cases - если будешь разделять
- [ ] 12. Добавить валидацию входных данных - на уровне Application

По первому вопросу (один vs несколько Use Cases):

- Начни с ОДНОГО Use Case - ScheduleDownloadCommand
- Разделяй только когда появится дублирование логики
- Сфокусируйся на транзакционной целостности

По второму вопросу (обработка ответов):
Возвращай типизированный Result с вариантами:
Уже скачан
Уже в очереди
Добавлен в очередь
Ошибка валидации

Адаптер маппит эти варианты в Telegram сообщения
Порядок работы:
Почини критические ошибки (2-4 часа)
Проектирование архитектуры (1-2 часа)
Реализация базового сценария (3-4 часа)
Добавление обработки edge cases (2-3 часа)

# Начни с минимального рабочего Use Case, затем расширяй. Не пытайся сразу сделать идеально - итеративно улучшай.

---

- не понимаю как быть с юс-кейсами
  - смотри. я могу написать один юс-кейс, который будет включать всю последовательность - и проверка наличия в репозитории и скачивание и запись в репозиторий.
  - а также могу создать для каждого этого шага собственный юс-кейс
  - хочу делать скорее по первому варианту
- на каком уровне прописывать обработку ответов?
  - юс-кейс это download-resource-use-case или process-message-use-case

- [ ] почему domain содержится в telegram-bot directory?
