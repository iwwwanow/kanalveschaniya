- [ ] infra
  - [ ] QueueRepositoryImpl
    - `TODO map to domain instance`

---

- [x] разбираюсь с drizzle. не запускается через bunjs. через npx вроде работает

---

- [ ] download adapter
- cron on processors on adapters or infra?
- repositories on infra
- composition root on infra
- config on infra/composition root/ entrypoint

---

- [ ] инфра и адаптеры
  - для начала выясни что это такое. границы их возможностей

---

- [x] остановился на рефакторинге QueueTask

---

- [ ] application, use-cases
  - для начала пойми, какие юс-кейсы вообще нужны
  - [ ] download-use-case
    - нужно теперь написать юс-кейс для скачивания
    - обрати внимание, что сслышки будут браться из очереди, и отправляться на третий сервис
    - как будет выглядеть этот адаптер для третьего сервиса?
    - там по сути будет только фетч на третий сервис и все.
    - вопрос в том, как он будет реализовываться на уровне application
    -
    - мне не нравится то, что интерфейс для адапрета определяется в application/interface.
    - при том, что похожий функционал определяется в dtos
    - может быть можно подобрать более подходящий, более спецефичный нейминг для adapter-interfaces?
- [ ] domain, unit-tests
- [ ] application, unit-tests
- [ ] application, integration-tests

---

- [x] formatting
- [ ] linting
- [ ] typecheck

- [ ] нужна команда download. лучше даже не команду, просто обработка вообще всех сообщений как ссылок

- cobalt deepwiki - https://deepwiki.com/imputnet/cobalt
- sc cobalt code - https://github.com/imputnet/cobalt/blob/47d8ccbc17aeeac6cb754c8b721c2148f007c103/api/src/processing/services/soundcloud.js#L11

```
Конкретная цепочка вызовов:
bot/application/use-cases/handle-command.use-case.ts
Получает команду /download от presentation слоя
Вызывает shared/application/use-cases/download-track.use-case.ts

shared/application/download-track.use-case.ts
Проверяет кэш через TrackRepository (domain слой)
Если трека нет в кэше → вызывает packages/downloader

packages/downloader
Это infrastructure-пакет, который знает КАК скачивать
Использует внешние библиотеки (yt-dlp, axios и т.д.)
Возвращает результат скачивания (файл, метаданные)
Возврат по цепочке:
downloader → shared/application → bot/application → bot/presentation
```

---

- bunjs
- sqlite db (drizzle orm)
  - нужна очередь на скачивание
  - нужна для того, чтобы не скачивать уже скачанные треки, а брать их из кэша
- ddd + (clean)

### mvp use-cases:

- download track by url
  - check track by url in DB
    - if has it - send it
    - if not has it - download it and write data into db
  - post it to channel

### use-cases:

- download likes
- download playlist

---

- ревью по чату:
  - `https://chat.deepseek.com/a/chat/s/ed710248-632c-4279-8583-d28d4bca166e`

---

- [ ] FIX: bun db:migrate не работает. можно запускаться только из инфры и только через npm run ...
- [ ] FIX: ты ошибся в том, что в директории telegram-bot у тебя есть модуль domain. это в корне неверно. приложение твое - канал вещания. он не должен быть привязан к вендору

---

- [ ] запускайся и собирайся на ноде. не еби мозги
  - [ ] workspaces
  - [ ] typescript
  - [ ] eslint
  - [ ] esbuild

---

- [x] 1. Неправильная обработка ошибок - Use Case смешивает исключения и Result объекты. Либо обрабатывай ВСЕ ошибки через Result, либо ВСЕ через исключения
- [?] 2. Отсутствие валидации Command - Command принимает Value Objects, но нет проверки их валидности на уровне Application
  - value-objects валидируется в конструкторе. следовательно они должны быть валидными и при создании
- [?] 3. Проблема race condition - между проверкой "не в очереди" и добавлением в очередь может вклиниться другой процесс
  - на уровне доменной логики можно ли както дописать то, что resourceUrl должен быть униальным?
  - если в очереди должно быть несколько объектов с одинаковым resourceUrl, для того, чтобы оповестить отправителя - как сделать? или создать дополнительную очередь для оповещения?
- [x] 4. Нарушение CQRS - Use Case возвращает Entity объекты (QueueTask, Resource), что раскрывает внутреннюю структуру
  - вообще не понимаю этого ограничения. много неудобств накладывает. например из application, при найденном ресурсе я бы просто его возаращал. а так мне нужно извлекать из resourceId
  - могу ли я использовать value-objects из entity в applicatoin/dto?
- [?] 5. Отсутствие фабрики для QueueTask - используется статический метод create, но нет обработки возможных ошибок создания
  - в комманд попадают уже value-objects. насколько понимаю, валидация в конструкторе, следовательно они все гарантированно валидные.
  - также, насколько понимаю, value-objects не должны попадать в инфрку. инфра передает в эппликейшн только строки. далее мы из них собираем value-objects и на месте валидируем. веро?
- [x] 6. Избыточный базовый Command класс - не несет полезной нагрузки, можно удалить
- [ ] 7. Проблема с оповещениями - архитектурно не решено, как оповещать пользователя в случае AlreadyQueued
  - мы возаращаем в инфру chatId, messageId, затем инфра оповещает
- [?] 8. Некорректные импорты типов - используются type imports там где нужны реальные классы
  - не понимаю где
- [x] 9. Отсутствие композиции Use Cases - весь сценарий в одном методе, сложно тестировать и расширять
- [x] 10. Неиспользуемые ошибки в Result - объявлены ValidationError и SystemError, но не используются
  - убрал
- [x] 11. Смешение уровней абстракции - Use Case знает о конкретных ошибках БД и файловой системы
  - убрал
- [-] 12. Отсутствие транзакционности - несколько операций с репозиториями не объединены в транзакцию
  - пока оставим
- [?] 13. Проблема с возвращаемыми данными - AlreadyQueued возвращает задачу, но нет информации о позиции в очереди
  - позиция в очереди будет считаться. нужно высчитывать количество задач сверху. они будут сортироваться по дате
- [?] 14. Жесткая зависимость от доменных Entity - Use Case напрямую возвращает доменные объекты
  - нужно добавлять в application-layer логику работы с оповещениями. както нужно прописать функции для отправки сообщений (или их интерфейсы)
  - далее через инфру прокидывать адаптер. логика будет вот тут
- [x] 15. Отсутствие мониторинга - нет логирования операций для отладки

---

- [ ] гоняй теперь ревью.
  - 2-3 ревью должно быть достаточно

---

### [ ] Почини критические ошибки (2-4 часа)

[x] Создать ScheduleDownloadCommand класс в application/dtos/
[x] Перенести resourceUrl, chatId, messageId в Command

- в целом, детализация комманды. что нужно для выполнения?
- обрати внимание, что ты будешь записывать в БД с айди чата и айди пользователя. также нужен УРЛ. думаю, имеет смысл сохранять еще и messageId, чтобы генерить ответ на сообщение
  [x] Изменить execute на async execute(command: ScheduleDownloadCommand)
  [x] Убрать any из возвращаемого типа

[x] Создать ScheduleDownloadResult тип с вариантами: - Success (task: QueueTask) - AlreadyDownloaded (resource: Resource) - AlreadyInQueue (task: QueueTask) - ValidationError (message: string)
[x] Определить какие ошибки доменные (AlreadyExists), какие системные (DatabaseError)
[x] Решить: доменные ошибки - часть Result, системные - исключения

[x] Сделать queueRepository и resourceRepository приватными
[x] Добавить async ко всем методам в Use Case
[x] Обновить интерфейсы репозиториев на Promise

[x] Реализовать проверку в ResourceRepository (скачан ли ранее)
[x] Реализовать проверку в QueueRepository (есть ли в очереди)
[x] Реализовать создание QueueTask и добавление в очередь
[x] Возвращать соответствующий Result вариант

### [ ] Проектирование архитектуры (1-2 часа)

### [ ] Реализация базового сценария (3-4 часа)

### [ ] Добавление обработки edge cases (2-3 часа)

# Последовательность рефакторинга Application Layer:

- [x] 1. Исправить сигнатуру execute - убрать any, определить Command объект
- [x] 2. Сделать зависимости приватными - убрать public readonly
- [x] 3. Добавить асинхронность - все методы async
- [x] 4. Определить типизированный Result - вместо any
- [x] 5. Выбрать стратегию Use Case - один большой или разделенные
- [x] 6. Определить границы транзакций - что атомарно, что нет
- [x] 7. Спроектировать обработку ошибок - доменные vs системные
- [x] 8. Определить входные DTO - Command vs Query объекты
- [-] 9. Реализовать проверку состояния - race condition protection
- [-] 10. Добавить доменные события - уведомления о изменениях
- [x] 11. Проектировать композицию Use Cases - если будешь разделять
- [ ] 12. Добавить валидацию входных данных - на уровне Application

По первому вопросу (один vs несколько Use Cases):

- Начни с ОДНОГО Use Case - ScheduleDownloadCommand
- Разделяй только когда появится дублирование логики
- Сфокусируйся на транзакционной целостности

По второму вопросу (обработка ответов):
Возвращай типизированный Result с вариантами:
Уже скачан
Уже в очереди
Добавлен в очередь
Ошибка валидации

Адаптер маппит эти варианты в Telegram сообщения
Порядок работы:
Почини критические ошибки (2-4 часа)
Проектирование архитектуры (1-2 часа)
Реализация базового сценария (3-4 часа)
Добавление обработки edge cases (2-3 часа)

# Начни с минимального рабочего Use Case, затем расширяй. Не пытайся сразу сделать идеально - итеративно улучшай.

---

- не понимаю как быть с юс-кейсами
  - смотри. я могу написать один юс-кейс, который будет включать всю последовательность - и проверка наличия в репозитории и скачивание и запись в репозиторий.
  - а также могу создать для каждого этого шага собственный юс-кейс
  - хочу делать скорее по первому варианту
- на каком уровне прописывать обработку ответов?
  - юс-кейс это download-resource-use-case или process-message-use-case

- [ ] почему domain содержится в telegram-bot directory?
