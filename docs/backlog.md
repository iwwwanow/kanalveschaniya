- делай ревью по чату:
  - https://chat.deepseek.com/a/chat/s/ed710248-632c-4279-8583-d28d4bca166e

- [ ] 1. Неправильная обработка ошибок - Use Case смешивает исключения и Result объекты. Либо обрабатывай ВСЕ ошибки через Result, либо ВСЕ через исключения
- [ ] 2. Отсутствие валидации Command - Command принимает Value Objects, но нет проверки их валидности на уровне Application
- [ ] 3. Проблема race condition - между проверкой "не в очереди" и добавлением в очередь может вклиниться другой процесс
- [ ] 4. Нарушение CQRS - Use Case возвращает Entity объекты (QueueTask, Resource), что раскрывает внутреннюю структуру
- [ ] 5. Отсутствие фабрики для QueueTask - используется статический метод create, но нет обработки возможных ошибок создания
- [ ] 6. Избыточный базовый Command класс - не несет полезной нагрузки, можно удалить
- [ ] 7. Проблема с оповещениями - архитектурно не решено, как оповещать пользователя в случае AlreadyQueued
- [ ] 8. Некорректные импорты типов - используются type imports там где нужны реальные классы
- [ ] 9. Отсутствие композиции Use Cases - весь сценарий в одном методе, сложно тестировать и расширять
- [ ] 10. Неиспользуемые ошибки в Result - объявлены ValidationError и SystemError, но не используются
- [ ] 11. Смешение уровней абстракции - Use Case знает о конкретных ошибках БД и файловой системы
- [ ] 12. Отсутствие транзакционности - несколько операций с репозиториями не объединены в транзакцию
- [ ] 13. Проблема с возвращаемыми данными - AlreadyQueued возвращает задачу, но нет информации о позиции в очереди
- [ ] 14. Жесткая зависимость от доменных Entity - Use Case напрямую возвращает доменные объекты
- [ ] 15. Отсутствие мониторинга - нет логирования операций для отладки

---

- [ ] гоняй теперь ревью.
  - 2-3 ревью должно быть достаточно

---

### [ ] Почини критические ошибки (2-4 часа)
[x] Создать ScheduleDownloadCommand класс в application/dtos/
[x] Перенести resourceUrl, chatId, messageId в Command
  - в целом, детализация комманды. что нужно для выполнения?
  - обрати внимание, что ты будешь записывать в БД с айди чата и айди пользователя. также нужен УРЛ. думаю, имеет смысл сохранять еще и messageId, чтобы генерить ответ на сообщение
[x] Изменить execute на async execute(command: ScheduleDownloadCommand)
[x] Убрать any из возвращаемого типа

[x] Создать ScheduleDownloadResult тип с вариантами:
    - Success (task: QueueTask)
    - AlreadyDownloaded (resource: Resource)
    - AlreadyInQueue (task: QueueTask)
    - ValidationError (message: string)
[x] Определить какие ошибки доменные (AlreadyExists), какие системные (DatabaseError)
[x] Решить: доменные ошибки - часть Result, системные - исключения

[x] Сделать queueRepository и resourceRepository приватными
[x] Добавить async ко всем методам в Use Case
[x] Обновить интерфейсы репозиториев на Promise

[x] Реализовать проверку в ResourceRepository (скачан ли ранее)
[x] Реализовать проверку в QueueRepository (есть ли в очереди)
[x] Реализовать создание QueueTask и добавление в очередь
[x] Возвращать соответствующий Result вариант
### [ ] Проектирование архитектуры (1-2 часа)
### [ ] Реализация базового сценария (3-4 часа)
### [ ] Добавление обработки edge cases (2-3 часа)

# Последовательность рефакторинга Application Layer:
- [x] 1. Исправить сигнатуру execute - убрать any, определить Command объект
- [x] 2. Сделать зависимости приватными - убрать public readonly
- [x] 3. Добавить асинхронность - все методы async
- [x] 4. Определить типизированный Result - вместо any
- [x] 5. Выбрать стратегию Use Case - один большой или разделенные
- [x] 6. Определить границы транзакций - что атомарно, что нет
- [x] 7. Спроектировать обработку ошибок - доменные vs системные
- [x] 8. Определить входные DTO - Command vs Query объекты
- [-] 9. Реализовать проверку состояния - race condition protection
- [-] 10. Добавить доменные события - уведомления о изменениях
- [x] 11. Проектировать композицию Use Cases - если будешь разделять
- [ ] 12. Добавить валидацию входных данных - на уровне Application

По первому вопросу (один vs несколько Use Cases):
  - Начни с ОДНОГО Use Case - ScheduleDownloadCommand
  - Разделяй только когда появится дублирование логики
  - Сфокусируйся на транзакционной целостности

 По второму вопросу (обработка ответов):
Возвращай типизированный Result с вариантами:
Уже скачан
Уже в очереди
Добавлен в очередь
Ошибка валидации

Адаптер маппит эти варианты в Telegram сообщения
Порядок работы:
Почини критические ошибки (2-4 часа)
Проектирование архитектуры (1-2 часа)
Реализация базового сценария (3-4 часа)
Добавление обработки edge cases (2-3 часа)
# Начни с минимального рабочего Use Case, затем расширяй. Не пытайся сразу сделать идеально - итеративно улучшай.

---

- не понимаю как быть с юс-кейсами
  - смотри. я могу написать один юс-кейс, который будет включать всю последовательность - и проверка наличия в репозитории и скачивание и запись в репозиторий.
  - а также могу создать для каждого этого шага собственный юс-кейс
  - хочу делать скорее по первому варианту
- на каком уровне прописывать обработку ответов?
  - юс-кейс это download-resource-use-case или process-message-use-case

- [ ] почему domain содержится в telegram-bot directory?
